# 스크린샷 도구(Snipping tool) 개발 과정에서의 문제 해결

현재 진행하고 있는 프로젝트중 요구사항을 구현하기 위해 스크린 캡처도구를 직접 구현해야하는 일이 있었고 이를 직접 구현하면서 Github에서 유사한 구현체들을 참고하면서 개발 하게 되었다. 그러나 이 과정에서 몇 가지 문제에 직면했는데 이 글에서는 문제 해결 과정을 공유하고자 한다.

## 문제 1: 해상도에 따른 지정 영역과 실제 영역의 오차

처음 구현한 스크린샷 도구는 해상도에 따라 지정한 영역과 실제 캡처된 영역에 오차가 발생하는 문제가 있었는데 고해상도의 화면에서만 해당 문제가 발생하였다. 이를 바탕으로 디스플레이의 배율 값을 불러와서 오차를 수정하면 될 것 같았다.

### 문제 해결 과정

1. **스택오버플로우 질문[[Link](https://stackoverflow.com/questions/78568755/pyside-snipping-tool-coordinates-mismatch-due-to-monitor-scaling-and-dual-monito)]**:

   스크린샷 도구의 해상도 문제를 해결하기 위해 스택오버플로우에 질문을 통해 다음과 같은 코멘트를 받았다:
   ```
   You should read the QScreen, QPaintDevice (from which QWidget inherits) and the DPI related documentation.
   ```
   
3. **공식 문서 읽기**:
   QScreen, QPaintDevice 및 DPI 관련 문서를 읽고, 각각의 모니터마다 `devicePixelRatio()` 값을 불러와서 사용하기로 했습니다.

4. **코드 수정**:
   `devicePixelRatio()` 값을 불러와서, 각 모니터마다 오차를 수정하기 위해 곱해주는 방식으로 코드를 수정했습니다. 다음은 수정된 코드의 일부입니다:

   ```python
   class SnipWidget(QtWidgets.QWidget):
       #...
       def mouseReleaseEvent(self, event):
           #...
           x1 = min(self.begin.x(), self.end.x()) * self.scale_factor + self.screen_geometry.x()
           y1 = min(self.begin.y(), self.end.y()) * self.scale_factor + self.screen_geometry.y()
           x2 = max(self.begin.x(), self.end.x()) * self.scale_factor + self.screen_geometry.x()
           y2 = max(self.begin.y(), self.end.y()) * self.scale_factor + self.screen_geometry.y()
           #...
   ```

이렇게 `devicePixelRatio()` 값을 사용하여 해상도에 따른 오차 문제를 해결했습니다.

## 문제 2: 듀얼 모니터 지원 확장

해상도 문제를 해결한 후, 듀얼 모니터 환경에서도 스크린샷 도구가 정상적으로 동작하도록 기능을 확장했다. 이를 위해 각 모니터의 스크린 지오메트리를 읽어와서 각각의 모니터에 대해 스크린샷을 캡처하도록 수정했다.

### 코드 설명

다음은 듀얼 모니터를 지원하도록 확장된 코드입니다:

```python
import sys
from PySide6 import QtWidgets, QtCore, QtGui
from PIL import ImageGrab
import numpy as np
import cv2

class SnipWidget(QtWidgets.QWidget):
    def __init__(self, screen_geometry, scale_factor):
        super().__init__()
        self.screen_geometry = screen_geometry
        self.scale_factor = scale_factor
        self.setGeometry(self.screen_geometry)
        self.setWindowTitle(' ')
        self.begin = QtCore.QPoint()
        self.end = QtCore.QPoint()
        self.setWindowOpacity(0.3)
        self.num_snip = 0
        self.is_snipping = False
        QtWidgets.QApplication.setOverrideCursor(
            QtGui.QCursor(QtCore.Qt.CrossCursor)
        )
        self.setWindowFlags(QtCore.Qt.FramelessWindowHint)
        self.show()

    def paintEvent(self, event):
        if self.is_snipping:
            brush_color = (0, 0, 0, 0)
            lw = 0
            opacity = 0
        else:
            brush_color = (128, 128, 255, 128)
            lw = 3
            opacity = 0.3

        self.setWindowOpacity(opacity)
        qp = QtGui.QPainter(self)
        qp.setPen(QtGui.QPen(QtGui.QColor('black'), lw))
        qp.setBrush(QtGui.QColor(*brush_color))
        qp.drawRect(QtCore.QRectF(self.begin, self.end))

    def keyPressEvent(self, event):
        if event.key() == QtCore.Qt.Key_Q:
            print('Quit')
            self.close()
        event.accept()

    def mousePressEvent(self, event):
        self.begin = event.position()
        self.end = self.begin
        self.update()

    def mouseMoveEvent(self, event):
        self.end = event.position()
        self.update()

    def mouseReleaseEvent(self, event):
        self.num_snip += 1
        x1 = min(self.begin.x(), self.end.x()) * self.scale_factor + self.screen_geometry.x()
        y1 = min(self.begin.y(), self.end.y()) * self.scale_factor + self.screen_geometry.y()
        x2 = max(self.begin.x(), self.end.x()) * self.scale_factor + self.screen_geometry.x()
        y2 = max(self.begin.y(), self.end.y()) * self.scale_factor + self.screen_geometry.y()
        self.is_snipping = True
        self.repaint()
        QtWidgets.QApplication.processEvents()
        img = ImageGrab.grab(bbox=(x1, y1, x2, y2), include_layered_windows=False, all_screens=True)
        self.is_snipping = False
        self.repaint()
        QtWidgets.QApplication.processEvents()
        img_name = 'snip{}.png'.format(self.num_snip)
        img.save(img_name)
        print(img_name, 'saved')
        img = cv2.cvtColor(np.array(img), cv2.COLOR_BGR2RGB)


class SnipApp(QtWidgets.QApplication):
    def __init__(self, argv):
        super().__init__(argv)
        self.widgets = []
        for screen in self.screens():
            screen_geometry = screen.geometry()
            print(screen_geometry)
            scale_factor = screen.devicePixelRatio()
            widget = SnipWidget(screen_geometry, scale_factor)
            self.widgets.append(widget)


if __name__ == '__main__':
    app = SnipApp(sys.argv)
    sys.exit(app.exec())
```

### 주요 수정 사항:

1. **`include_layered_windows=False` 및 `all_screens=True` 사용**:
   `ImageGrab.grab()` 함수에 `include_layered_windows=False` 및 `all_screens=True` 옵션을 추가하여 모든 모니터에서 스크린샷을 캡처할 수 있도록 했다.

2. **듀얼 모니터 지원**:
   `SnipApp` 클래스에서 각 모니터의 스크린 지오메트리를 읽어와서 각각의 모니터에 대해 `SnipWidget` 인스턴스를 생성하고, 이를 통해 다중 모니터에서도 스크린샷을 캡처할 수 있도록 했다.

### 결론

이렇게 두 가지 주요 문제를 해결하여 고해상도 및 듀얼 모니터 환경에서도 정확하게 동작하는 스크린샷 도구를 구현할 수 있었다. 다시 한번 느끼지만 공식문서를 통해 개발하는것이 중요하다고 느꼇고 질문을 통해 내가 현재 부족한게 무엇인지 바로 파악할 수 있었다. 어떤 모듈을 쓰는지 어떻게 참고한 구현체가 어떻게 동작하는지 소스 코드를 분석하고 개발하는게 중요하다고 느꼇다. 느낀것은 질문하는걸 두려워하지 않아야겠다. 질문을 통해 해당 문서를 읽어보라는 조언을 들었고 그래서 DPI가 무엇인지 문제파악을 통해 문제해결의 초석을 닦을수 있었다.
